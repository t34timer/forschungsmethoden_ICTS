\subsection{Categorizing the issues and commits}

If an assignment of a issue to a commit is not possible one might want to think of another way for narrowing them down to a specific category or something similar.
This section describes some ideas for achieving a categorization of commits and issues in order to be able to support mapping them manually or at least summarize those which refer to a similar topic.

\subsubsection{Why categorization?}

It is difficult to explicitly map commits to issues.
One reason for that are the four different cases which have to be considered in this kind of mapping.\\

In case one the commit is mapped to only one issue which makes the mapping pretty simple.
The commit is mapped to a corresponding issue and both are not to be used in any further mapping.
This only applies if it is safe to assume that each commit addresses one specific issue which leads to the second case.\\

In the second case it is allowed that one commit might belong to several issues.
Although this case is usually quite rare it cannot be ignored.
For instance implementing a function which was defined in a issue could lead to improve efficiency of another functionality or anything similar which was described in another issue.
Obviously the commit would address to two different issues in this case.\\

The third case would be the other way around which means mapping several commits to one issue.
This case is probably the one which is to be considered the most.
In many cases it is not possible to resolve a problem stated in a issue within a short amount of time.
This results in interrupting the work on the issue and continue working on it on another time.
In this case it is inevitable to save the changes which were already made which usually happens by committing them.
It is now necessary to be able to gather all commits linked to this specific issue and map them accordingly.\\
\newpage
The last case deals with mapping several commits to several issues.
This case might not be seen as actual case since it can be separated into either the second and the third case.
This separation depends on whether the commits are supposed to be mapped to issues or the other way around.
The most common case would be mapping commits to issues.
In this case one could simply look at each single commit and map it to its corresponding issues (case two).
The other way would imply to look at each single issue mapping it to its corresponding commits.\\

These 4 cases illustrate that the affiliation of a specific commit to a specific issue is not always to be taken for granted.
This leads to another way of mapping commits and issues without having to explicitly map them to each other.
Instead one creates categories out of the token of the commits and issues and relates the commits and issues to the category they fit in whereby it is not specified that they can only be mapped to one category.

\subsubsection{Creating categories}

Having already tokenized and lemmatized the commits and the issues the basis for a categorization of these commits and issues is established.
Knowing how often a specific token (e.g. a specific word such as ''GUI'', ''bug'' or ''interface'') occurs, enables the creation of categories  depending on their occurrences.
It would be possible to map commits and issues which contain the word ''GUI'' to the corresponding category.
For designing this mapping process it is important to determine some restriction for creating categories as well as assigning commits and issues to them. 

\paragraph{Quantity of keywords}

In order to create a category we need to define a quantity of words referring to the same part of the software.
For instance in order to refer to the ''graphical user interface'' you could write about the ''GUI'' or about the ''front end''.
It is also possible to simple refer to it as ''user interface'' or ''UI''.
These mentioned words would be the quantity of words for the graphical user interface. \\

As you can see creating a category makes use of several (different) tokens which might be valid in several categories.
Assigning ''user interface'' to the category of the graphical user interface implies that the token ''interface'' is mapped to this category as well.
If a commit or issue now refers to another kind of ''interface'' such as ''library interface'' is it not possible to map it to a unique category.
This raises the question of how to handle this kind of overlapping. 

\paragraph{Frequency range and token summary}

On the one hand one could assume that words which are written next to each other (e.g. ''user'' and  ''interface'') have the same frequency within this issue with a deviation of 'x'.
The deviation is necessary because the token ''user'' could be referred to independent to the word ''interface''.
This also applies the other way around. \\

One the other hand this assumption does not guarantee an explicit mapping.
Considering the fact that categorizing issues and commits is only done if a specific mapping of them failed one should think about loosen the constraints.
In order to summarize several tokens to a single one the definition should not rely on the frequency itself and it should not aim to a specific mapping.
A loosened definition enables a summary of several words to a ''new token'' for the categorization which raises the chance of successfully mapping commits and issues.
In this case the user can optionally define a threshold for a frequency of a token which has to be met in order to be used for the creation of a new token and finally a new category.


\subsubsection{Mapping to categories}

Generally one would assume that a commit or issue which was mapped once cannot be mapped again.
This does not apply to mapping commits and issues to categories since a commit or issue can refer to several categories.
This depends on the created categories and cannot be defined generally.\\
This leads to mapping commits and issues to categories independent of them being already mapped.
Also the result or components of the previous mapping should influence further mappings.
The mapping itself depends on the categories and the tokens they were made of.
Basically all commits and issues which contain a token fitting into any category are mapped to it accordingly. \\

Concerning the mapping there are some tolerances which the user himself can adapt to his needs and preferences.
For instance the user can define a threshold for the frequency which has to be met in order to be mapped to a category.
This threshold might even be related to the threshold for the creation of the category itself. \\

The way of mapping commits and issues to a category as well as the way of creating those categories has many aspects which can be changed and adapted by the user.
They can depend on preferences, previous experiences or correlations between the token frequency.

